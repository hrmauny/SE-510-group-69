# Project 1
## System/Product Reviews
1) SlashBot
2) Application Tracking System
3) Simplii
4) Classmate Bot
5) WolfTrack 3.0

## Video Link
[Running Slashbot Application](https://drive.google.com/file/d/1LvPqmk5BjSCgJ8kkGBvGGYqh1eSZp_6-/view?pli=1) 

## Challenges of Slashbot: Lessons Learned and RoadMap for Project Phase 2

While running our project, slashbot we ran into a range of difficulties. In this essay, we will dive into the specific obstacles we faced, what made them particularly arduous, and what measures  we are committing to take in Project 2 to avoid repeating these pitfalls.

1. **Installation Steps**

One of the initial hurdles in our Slashbot project was the murky path of installation. The documentation provided for installation steps was vague at best and lacked clarity. 

What made this ordeal even more trying was the absence of troubleshooting steps for common issues. When our team members inevitably ran into roadblocks, we were left to fend for ourselves, often spending hours searching for solutions online. This was probably the longest step we took to run this project. It was an exercise in frustration, and it could have been avoided with clear, step-by-step installation instructions. In Project 2, we commit to provide comprehensive installation guides and include a dedicated section for troubleshooting common issues to ensure a smoother setup process for everyone involved.

2. **Deprecated Libraries and Software**

The second challenge was the use of deprecated libraries and software within Slashbot. No changes had been made in the repository since 2021 which caused a lot of libraries used in the project to deprecate. Each time we tried to fix one library one or the other dependencies failed. This had two major repercussions.

Firstly, it hindered our productivity. We spent countless hours patching together outdated code and libraries, making it work with the newer components. Secondly, it exposed our project to security risks, as deprecated software often lacks critical updates and patches.

To avoid this pain in Project 2, we are committing to a rigorous review of all libraries and software components we intend to use. We will ensure that we only integrate tools that are actively maintained and up-to-date. Additionally, we will implement a regular review process during the project's lifecycle to identify and replace any deprecated elements promptly.

3. **Inaccurate Functionalities**

Testing is a crucial aspect of any project's development. In Slashbot, we faced an unexpected challenge â€“ the functionalities we were testing were not accurately reflecting the latest changes. This led to incorrect testing results, causing confusion and delaying our progress.

The root of this problem was the lack of a streamlined process for updating functionalities. As a result, some of our testing scripts were pulling data from older versions of our project, leading to skewed results.

To prevent this in project 2, we will establish a clear protocol for updating and tracking functionalities. This will include regular meetings among us to ensure that everyone is on the same page regarding any changes or updates. By maintaining an accurate reflection of our project's functionalities, we can ensure more reliable testing results.

4. **Unused Imports and Confusing Naming Conventions**

Coding can often feel like solving a puzzle. However, in Slashbot, the puzzle was made more complex by the presence of unused imports and confusing naming conventions. These seemingly small issues had a significant impact on our project's readability and maintainability.

Unused imports cluttered our codebase and made it difficult to discern which libraries were essential. This, in turn, affected the project's performance and made debugging a headache. Confusing naming conventions added another layer of complexity, as team members had to decipher variable and function names to understand their purpose.

In project 2, we are committing to maintain a clean and organized codebase. We will try to regularly review and remove unused imports to keep the codebase clutter-free. Additionally, we will enforce clear and consistent naming conventions across the entire project, making it easier for team members to navigate the code efficiently.

5. **API Token Management**

Lastly, Slashbot's reliance on API tokens presented a unique challenge. To use these tokens, team members had to either add them to their bash profiles for permanent access or export them every time they used Telebot.

In project 2, our aim will be to simplify API token management by providing clear guidelines and a standardized approach. We will document the recommended method for managing API tokens, ensuring that all team members follow the same procedure. This will reduce confusion and streamline the process of accessing these tokens, ultimately improving efficiency.

In conclusion, running the Slashbot project was a valuable learning experience filled with challenges. The difficulties we faced, from unclear installation steps to deprecated libraries and confusing naming conventions, were indeed painful. However, these challenges have equipped us with useful insights and a clear roadmap for project 2.

We commit to addressing these pain points head-on by providing comprehensive installation instructions, using up-to-date libraries and software, maintaining accurate functionality tracking, organizing our codebase meticulously, and streamlining API token management. With these practices in place, I am confident that project 2 will sail smoother seas and reach its destination with greater ease and success.


